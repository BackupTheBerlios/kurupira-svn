/*
 * Copyright (C) by The Freecolony Project.
 * Please refer to the COPYRIGHT file distributed with this source
 * distribution.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the
 * Free Software Foundation, Inc.,
 * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
 
/**
 * @file llp_sessions.h Procedures used to manage sessions.
 * @ingroup llp
 */

#ifndef _LLP_SESSIONS_H_
#define _LLP_SESSIONS_H_

#include <netinet/in.h>

#include <pthread.h>
#include <openssl/bn.h>

#include <libfreedom/types.h>
#include <util/util_crypto.h>

#include "llp_packets.h"

/**
 * Maximum number of sessions supported.
 */
#define LLP_MAX_SESSIONS	256

/**
 * Enumeration of the possible states that a session can be in.
 */
enum llp_states {
	LLP_STATE_CLOSED,				/**< Session is closed. */
	LLP_STATE_CONNECTING,			/**< Session is trying to connect. */
	LLP_STATE_BEING_CONNECTED,		/**< Some host is trying to connect. */
	LLP_STATE_ESTABLISHED,			/**< The connection is alive. */
	LLP_STATE_CLOSE_WAIT,			/**< Trying to close this session. */
	LLP_STATE_TIME_WAIT				/**< Waiting for new close requests. */
};

/**
 * Array that stores string identifiers for each possible state (indexed by
 * enum llp_sessions.
 */
extern char *llp_states[];

/**
 * The session traffic is encrypted.
 */
#define LLP_SESSION_ENCRYPTED 		1
/**
 * The session traffic is sent in plaintext.
 */
#define LLP_SESSION_NOT_ENCRYPTED	0

/**
 * Time atom used to handle time intervals (in milliseconds).
 */
#define LLP_TIME_TICK					500
/**
 * Number of time ticks per second.
 */
#define LLP_TIME_TICKS_PER_SECOND		(1000/LLP_TIME_TICK)
/**
 * General timeout used in various phases of the protocol (in LLP_TIME_TICKs).
 */
#define LLP_T_TIMEOUT	(30*LLP_TIME_TICKS_PER_SECOND)
/**
 * Timeout used in keep-alive timeouts (in LLP_TIME_TICKs).
 */
#define LLP_T_SILENT	(LLP_T_TIMEOUT/2 - LLP_TIME_TICKS_PER_SECOND)

/**
 * Data type that stores the information associated with a session.
 */
typedef struct {
	/** State that this session is in. */
	int state;
	/** Address of peer connected in session. */
	struct sockaddr_in address;
	/** Number os packets sent in session. */
	int packets_sent;
	/** Number of packets received in session. */
	int packets_received;
	/** Session traffic is encrypted or no. */
	int encrypted;
	/** Current timeout in number of LLP_TIME_TICKs (depends on state). */
	int timeout;
	/** Time that this is in silence (in LLP_TIME_TICKs). */
	int silence;
	/** System time when the last LLP_NODE_HUNT packet was sent. */
	long hunt_time;
	/** Time that this session is alive (in LLP_TIME_TICKs). */
	int alive;
	/** Code of the last error occurred in session. */
	int error;
	/** Connected peer's session. */
	int foreign_session;
	/** Encryption function used. */
	util_cipher_function_t *cipher;
	/** Hash function used. */
	util_hash_function_t *hash;
	/** MAC function used. */
	util_mac_function_t *mac;
	/** Key to decrypt incoming traffic. */
	u_char *cipher_in_key;
	/** Initialization vector of decryption. */
	u_char *cipher_in_iv;
	/** Key to encrypt outgoing traffic. */
	u_char *cipher_out_key;
	/** Initialization vector of encryption. */
	u_char *cipher_out_iv;
	/** Key to verify MAC of incoming traffic. */
	u_char *mac_in_key;
	/** Key to generate MAC of outgoing traffic. */
	u_char *mac_out_key;
	/** Entropy enforcer received (used to generate decryption key). */
	u_char h_in[LLP_H_LENGTH];
	/** Entropy enforced sent (used to generate encryption key). */
	u_char h_out[LLP_H_LENGTH];
	/** Diffie & Hellman (g^x mod p) received. */
	u_char y_in[LLP_Y_LENGTH];
	/** Diffie & Hellman (g^x mod p) sent. */
	u_char y_out[LLP_Y_LENGTH];
	/** Diffie & Hellman random exponent. */
	u_char x[LLP_X_LENGTH];
	/** Shared secret generated by Diffie & Hellman key agreement. */
	u_char z[LLP_Z_LENGTH];
	/** HASH(z), used to closing control. */
	u_char *verifier;
} llp_session_t;

/**
 * Array that stores the session information for each session present on the
 * link layer. Access to this structure must be governed my mutexes.
 */
extern llp_session_t llp_sessions[LLP_MAX_SESSIONS];

/**
 * Lock used to access the llp_sessions vector.
 */
extern pthread_mutex_t llp_sessions_mutexes[LLP_MAX_SESSIONS];

/**
 * Initializes the data structures that store session information and access
 * mutexes.
 * 
 * @return LLP_OK if no errors occurred, LLP_ERROR otherwise.
 */
int llp_sessions_initialize();

/**
 * Frees the memory associated with session information and access mutexes.
 */
void llp_sessions_finalize();

/**
 * Macro used to lock a session.
 * 
 * @param session session to be locked.
 */
#define llp_lock_session(session)	\
		pthread_mutex_lock(&llp_sessions_mutexes[session])
		
/**
 * Macro used to unlock a session.
 * 
 * @param session session to be unlocked.
 */
#define llp_unlock_session(session)	\
		pthread_mutex_unlock(&llp_sessions_mutexes[session])

/**
 * Copies the given key to the session decryption key.
 * 
 * @param session session identifier.
 * @param key key to be copied to session.
 * @return LLP_OK if no errors occurred, LLP_ERROR otherwise.
 */
int llp_set_cipher_in_key(int session, u_char *key);

/**
 * Copies the given initialization vector to the session decryption iv.
 * 
 * @param session session identifier.
 * @param iv parameter to be copied to session.
 * @return LLP_OK if no errors occurred, LLP_ERROR otherwise.
 */
int llp_set_cipher_in_iv(int session, u_char *iv);

/**
 * Copies the given key to the session encryption key.
 * 
 * @param session session identifier.
 * @param key key to be copied to session.
 * @return LLP_OK if no errors occurred, LLP_ERROR otherwise.
 */
int llp_set_cipher_out_key(int session, u_char *key);

/**
 * Copies the given initialization vector to the session encryption iv.
 * 
 * @param session session identifier.
 * @param iv parameter to be copied to session.
 * @return LLP_OK if no errors occurred, LLP_ERROR otherwise.
 */
int llp_set_cipher_out_iv(int session, u_char *iv);

/**
 * Copies the given key to the session mac generation key.
 * 
 * @param session session identifier.
 * @param key key to be copied to session.
 * @return LLP_OK if no errors occurred, LLP_ERROR otherwise.
 */
int llp_set_mac_in_key(int session, u_char *key);

/**
 * Copies the given key to the session mac verification key.
 * 
 * @param session session identifier.
 * @param key key to be copied to session.
 * @return LLP_OK if no errors occurred, LLP_ERROR otherwise.
 */
int llp_set_mac_out_key(int session, u_char *key);

/**
 * Copies the given verifier to the closing control verifier.
 * 
 * @param session session identifier.
 * @param verifier verifeir to be copied to session.
 * @return LLP_OK if no errors occurred, LLP_ERROR otherwise.
 */
int llp_set_verifier(int session, u_char *verifier);

/**
 * Closes the given session, freeing the allocated resources.
 */
void llp_close_session(int session);

/**
 * Returns the first free session (a session in closed state.)
 * 
 * @param next_state state that the session must be put int, so that subsequent
 * 		calls won't return the same session.
 * @return a free session identifier, LLP_ERROR if no sessions are free.
 */
int llp_get_free_session(int next_state);

/**
 * Returns the last error occurred in session.
 */
int llp_get_last_error(int session);

/**
 * Controls the timeouts and expiration time associated with each session.
 */
void llp_handle_timeouts();

/**
 * Keep-alive management.
 */
void llp_handle_silence();

/**
 * Management of number of established connections.
 */
void llp_handle_connections();

#endif /* !_LLP_SESSIONS_H_ */
